## 简介
介绍`open`、`read`、`write`、`lseek`和`close`这几个常用的文件IO函数。这几个文件IO通常被称为不带缓冲的IO(是一个系统调用)。

还会讨论缓冲区长度对这些操作的影响，在使用这些函数的时候要考虑好一个合适的缓冲区长度。
还要介绍一下原子操作的概念，最后再介绍一下`dup`、`fcntl`、`sync`、`fsync`和`ioctl`函数

## 文件描述符
> 对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。

UNIX系统中的`shell`会把：
* 文件描述符0与`标准输入`关联
* 文件描述符1与`标准输出`关联
* 文件描述符2与`标准错误`关联

*注:(这是很多`unix`程序的使用惯例，与内核无关。但是不遵守这个惯例会有很多麻烦。)*

在`POSIX.1`标准中，对幻数0、1、2进行了标准化：
* `STDIN_FILENO` = 0
* `STDOUT_FILENO` = 1
* `STDERR_FILENO` = 2

*注：定义在`<unistd.h>`中*

文件描述符的变化范围是0~OPEN_MAX-1。(`sysconf(_SC_OPEN_MAX)`函数可以获取)



------



## open和openat函数

> 打开一个文件，返回文件描述符

### 函数定义

```c
#include <fcntl.h>

int open(const char *path,int oflag,...);
// 成功返回文件描述符，出错返回-1

int openat(int fd,const char *path,int oflag,...);
// 成功返回文件描述符，出错返回-1
```

### 参数说明

* `path`：要打开或创建的文件名
* `oflag`：定义了一些选项来控制**打开的方式**。在后文中详细介绍
* 可变参数列表：只有在使用open函数**创建文件**时，用来指定**文件权限**的。

`oflag`参数的可选项很多，但是分为了两类，一类是必填项，一类是可选项。这两者用**逻辑或运算符**连接起来

必填项有：

|值|说明|补充|
|:--:|:--:|:--:|
|`O_RDONLY`|只读的方式打开|大多数实现定义为**0**|
|`O_WRONLY`|只写的方式打开|大多数实现定义为**1**|
|`O_RDWR`|读写方式打开|大多数实现定义为**2**|
|`O_EXEC`|只执行打开||
|`O_SEARCH`|只搜索打开||

**注意：** 

> 1. 上面必填项中的五个值只能选一个
> 2. 最后一个值(只搜索)有很多系统都还没有支持。它的作用就是在目录打开时**验证它的搜索权限**，后续对此文件描述符操作时，不会再检查搜索权限了，注意是对目录文件

可选项有：

|值|说明|
|:--:|:---|
|`O_APPEND`|每次进行写操作时，都将内容追加到文件尾|
|`O_CLOEXEC`|把`FD_COLEXEC`常量设置为文件描述符标志|
|`O_CREAT`|若文件不存在则创建它。使用这个参数时，必须指定最后一个可变参数列表。(可以参考`creat`函数中的[mode_t](#creat函数)参数)|
|`O_DIRECTORY`|如果`path`引用的不是目录，则出错|
|`O_EXCL`|如果同时指定了`O_CREAT`参数，而文件存在则报错。这常用来测试一个文件是否存在，不存在就创建。这使得检测和创建为一个原子操作|
|`O_NOCTTY`|如果`path`引用的是一个**终端设备**，则不将该设备分配作为此进程的控制终端|
|`O_NOFOLLOW`|如果`path`引用的是一个**符号链接**，则报错|
|`O_NONBLOCK`|如果`path`引用的是一个FIFO、块特殊文件或者字符特殊文件，则将文件的后续IO操作设置为**非阻塞方式**|
|`O_SYNC`|让每次`write`等待物理IO操作完成，包括由该`write`操作引起的文件属性更新所需的IO|
|`O_TRUNC`|如果文件存在，而且为只写或读写方式打开，则将文件长度截断为0|
|`O_TTY_INIT`|如果打开一个还未打开的终端设备，设置非标准`termios`参数值，使其符合`Single UNIX Specification`|
|`O_DSYNC`|是每次`write`要等待物理IO操作完成，但是如果该写操作并不影响读取刚刚写入的数据，则不需要等待文件属性被更新|
|`O_RSYNC`|是每一个以文件描述符作为参数运行的`read`操作等待，直至所有对文件同一部分挂起的写操作都完成|
| 各实现的差异  | 对于`O_SYNC`、`O_DSYNC`和`O_RSYNC`这三个标志，各实现的支持各不相同需要查看相应的文件资料。 |

### 细节说明

由`open`和`openat`函数返回的一定是**最小**的**未使用**的描述符数值。

可以看到`fd`参数把两个函数区分开，有以下几种情况：

1. `path`参数是**绝对路径**时，`fd`参数会被忽略，`openat`函数相当于`open`函数
2. `path`参数是**相对路径**时，
   1. `fd`参数指定了相对路径名在文件系统中的开始地址
   2. `fd`具有特殊值`AT_FDCWD`。这种情况，路径名在当前工作目录中获取。

`openat`函数是`POSIX.1`标准中新增的函数。主要是希望能解决两个问题：

1. 让线程可以使用相对路径名打开文件，而不再是只能相对于当前工作目录。
2. 希望能够解决TOCTTOU(time-of-check-to-time-of-use)问题

> TOCTTOU问题描述：如果有两个基于文件的函数调用，第二个函数调用依赖于第一个函数调用的结果，那么程序就是脆弱的。
> 因为这两个操作不是原子操作，在这两个函数调用之间文件可能发生了变化，这样就导致第一个函数调用的结果不在有效。
> 
> 通常用此错误来骗取特殊文件的权限等等。

文件名和路径名截断问题

* 文件名的最大长度可以通过`pathconf(path,_PC_NAME_MAX)`或`fpathconf(fd,_PC_NAME_MAX)`查询
* 在`POSIX.1`标准中，通过`_POSIX_NO_TRUNC`常量来决定是截断过长文件名或路径名，还是返回错误码
  * 查询方式：`pathconf(path,_PC_NO_TRUNC)`或`fpathconf(fd,_PC_NO_TRUNC)`



----



## creat函数

> 创建一个新文件，返回新文件的文件描述符

### 函数定义

```c
#include <fcntl.h>

int creat(const char *path, mode_t mode);
// 成功返回只写方式打开的文件描述符，出错返回-1
```

其实这个函数等效于

```c
int open(path,O_WRONLY | O_CREAT | O_TRUNC,mode);
```

### 参数说明

* `path`：文件名或路径名
* `mode`：新文件的权限(`<sys/stat.h>`)

| `st_mode` |       含义       |
| :-------: | :--------------: |
| `S_IRUSR` |      用户读      |
| `S_IWUSR` |      用户写      |
| `S_IXUSR` |     用户执行     |
| `S_IRGRP` |       组读       |
| `S_IWGRP` |       组写       |
| `S_IXGRP` |      组执行      |
| `S_IROTH` |      其他读      |
| `S_IWOTH` |      其他写      |
| `S_IXOTH` |     其他执行     |
| `S_IRWXU` | 用户读、写、执行 |
| `S_IRWXG` |  组读、写、执行  |
| `S_IRWXO` | 其他读、写、执行 |

### 细节说明

建议使用`open`函数来创建文件，因为`creat`函数有个小麻烦：它创建的文件都是以**只写**的方式打开的。如果我们想要以只读或或读写的方式打开，那么就要先`creat`再`close`然后在`open`，相当的麻烦，所以不如直接使用open函数。

*如果要创建的文件已经存在，`creat`函数会将文件内容截断为0，且文件的访问权限不变*

mode参数指定的权限回收`umake`值得影响



----



## close函数

> close函数，用来关闭一个打开的文件

```c
#include <unistd.h> // 注意头文件不一样
int close(int fd);
// 成功返回0，失败返回-1
```

关闭一个文件时还会释放该进程加载文件上的所有**记录锁**。

当一个进程终止时，内核会**自动关闭**它所打开的**所有文件**。



----

----



## lseek函数

> 修改当前文件偏移量。当打开一个文件时，除非指定`O_APPEND`选项，否则偏移量被设置为0。

### 函数定义

```c
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
// 成功返回新的当前文件偏移量，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `offset`：偏移的字节数，与`whence`有关
* `whence`：选项值
  * `SEEK_SET`：从文件开始处开始，偏移`offset`个字节
  * `SEEK_CUR`：从当前偏移量开始，偏移`offset`个字节**(可正可负)**
  * `SEEK_END`：从当前文件长度开始，偏移`offset`个字节**(可正可负)**

### 相关错误码

* 如果文件描述符指向的是一个管道、FIFO或网络套接字，则`lseek`返回-1，并将`error`设置为`ESPIPE`

### 细节说明

* 因为偏移量可能是负值，所以在比较`lseek`的返回值时应当注意，应该判断它是否等于-1，而不是小于0

* `lseek`仅将当前文件偏移量记录在内核中，**不会引起任何IO操作**

* 文件偏移量可以**大于文件的当前长度**，这种情况下，对文件的下次写会加长该文件，并在文件中构成一个**空洞**。位于文件中但没有写过的字节都被读为0。
* 文件的空洞并不要求在磁盘上占用存储区。



----



## read函数

> 从打开的文件中读取数据

### 函数定义

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);
// 成功返回读到的字节数，若到文件尾，返回0，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `buf`：用来存储数据的缓冲区
* `nbytes`：`buf`缓冲区的大小

### 细节说明

有多种情况使实际读到的字节数少于要求读的字节数：

* 读普通文件时，在读到要求的字节数之前已到达了文件尾端。
* 从终端设备读时，通常一次最多读一行
* 从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数
* 从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么`read`将只返回实际可用的字节数
* 当从某些面向记录的设备(如磁带)读时，一次最多返回一个记录
* 当一个信号造成终端，而已经读了一部分数据时



----



## write函数

> 向打开的文件写数据

### 函数定义

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t nbytes);
// 成功返回已写的字节数，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `buf`：用来存储数据的缓冲区
* `nbytes`：`buf`缓冲区的大小

### 细节说明

* `write`出错的常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制

* 如果打开文件时指定了`O_APPEND`选项，则每次写操作前，会将文件偏移量设置到文件结尾处，再写入数据。



----



## fcntl函数

fcntl函数，这是一个功能很丰富的函数

    #include <fcntl.h>
    
    int fcntl(int fd,int cmd,...);

#### 参数说明

* 第一个参数就不用多解释了，要进行操作的文件描述符
* 第二个参数决定了函数的功能，需要详细说一下

> fcntl函数一共有5中功能，对应有11中cmd参数
>
> * 复制一个已有的文件描述符(cmd = F_DUPFD || F_DUPFD_CLOEXEC) 
> * 获取/设置文件描述符状态(cmd = F_GETFD || F_SETFD)
> * 获取/设置文件状态标识(cmd = F_GETFL || F_SETFL)
> * 获取/设置一步I/O所有权(cmd = F_GETOWN || F_SETOWN)
> * 获取/设置纪录锁(cmd = F_GETLK || F_SETLK || F_SETLKW)
>
> 文件状态值的是文件的打开方式，前面的函数中有说过，文件的打开方式有五个单选项，
> 这五个打开方式是互斥的，所以通过F_GETFL获取到文件状态标示后需要用O_ACCMODE来获取相应的文件状态
>

* 第三个参数跟第二个参数有关

fcntl函数的返回值跟命令值有关，如果出错，所有命令都返回-1

#### 注意项

* 修改文件描述符标志或者文件状态标志时必须要谨慎，不能只是执行F_SETFD或者F_SETFL命令，这个会关闭之前开启的某些标志，所以最好先获取原有标志然后进行与运算符进行设置
* 设置某个标志位，就与相应的标识符进行与操作，关闭某个标志位，则是与上去反的标志位