[TOC]

## 链表
> 链式存储结构的特点：用一组任意的存储单元存储线性表的数据元素。这个存储单元可以是连续的，也可以是不是连续的

> 链表的数据元素称为结点
> 结点包含两个域：
* 数据域：存储实际的数据
* 指针域：存储指向下一个元素的指针

### 单链表的存储结构
```c
typedef _LIST_ELEM_TYPE_ int
typedef struct LNode {
      _LIST_ELEM_TYPE_ data;
      struct LNode *next;
  }LNode,*LinkList;
```

#### 首元结点、头结点和头指针
>首元结点：指链表中存储第一个数据元素的结点

> 头结点：指首元结点的结点。指针域指向首元结点，数据域不能存储任何信息，也可以存储与数据元素类型相同的其他附加信息。一般的会把链表的长度放在头结点的数据域中

> 头指针：指向链表中第一结点的指针

头结点的作用：
* 便于首元结点的处理
* 便于空表和非空表的统一处理

#### 单链表的初始化
```c
Status InitList(LinkList list) {
    list = malloc(sizeof(LNode));
    if (!list)
        return OVERFLOW;

    list->next = NULL;
    list->data = 0;
    return OK;
}
```

#### 获取数据元素的值
```c
int GetElem(LinkList list, int i, ElemType *elem) {
    if (i < 1 || i > list->data)
        return ERROR;

    LNode *p = list->next;
    int pos = 0;
    while (p && pos < i) {
        p = p->next;
        ++pos;
    }

    *elem = p->data;
    return OK;
}
```
时间复杂度为O(n)

#### 获取指定位置的数据元素
```c
int compare(ElemType l,ElemType r) {
    return (l == r);
}

LNode *LocateElem(LinkList list, ElemType elem, compare_func func) {
    LNode *p = list->next;
    while (p) {
        if (func(elem, p->data))
            return p;

        p = p->next;
    }

    return NULL;
}
```
第一次插入删除的时间复杂对为O(n)之后的插入删除操作均为O(1)

#### 插入删除数据元素
```c
int ListInsert(LinkList list, int i, ElemType elem) {
    if(i < 1 || i > list->data)
        return ERROR;

    LNode *pNew = malloc(sizeof(LNode));
    if (pNew == NULL)
        return OVERFLOW;
    pNew->data = elem;

    int pos = 1;
    LNode *pPrior = list;
    while (pPrior && pos < i) {
        pPrior = pPrior->next;
        ++pos;
    }

    pNew->next = pPrior->next;
    pPrior->next = pNew;

    ++list->data;
    return OK;
}

int ListDelete(LinkList list, int i, ElemType *elem) {
    if (i < 1 || i > list->data)
        return ERROR;

    int pos = 1;
    LNode *pPrior = list;
    while (pPrior && pos < i) {
        pPrior = pPrior->next;
        ++pos;
    }

    LNode *pDel = pPrior->next;
    pPrior->next = pDel->next;

    *elem = pDel->data;
    free(pDel);
    return OK;
}
```
第一次插入删除的时间复杂对为O(n)之后的插入删除操作均为O(1)

### 双向链表的存储结构
```c
typedef struct {
    ElemType data;
    struct DuLNode *prior;
    struct DuLNode *next;
} DuLnode, *DuLinkList;
```

#### 双向链表的插入
```c
// have head node
Status ListInsert(DuLinkList list, int i, ElemType e) {
    if (i < 1 || i > list->data)
        return ERROR;

    DuLNode *pNew = malloc(sizeof(DuLNode));
    if(!pNew)
        return ERROR;
    pNew->data = e;

    int pos = 1;
    DuLNode *pNode = list->next;
    while (pNode && pos < i) {
        pNode = pNode->next;
        ++pos;
    }

    pNew->prior = pNode->prior;
    pNew->prior->next = pNew;
    pNew->next = pNode;
    pNode->prior = pNew;

    ++list->data;
    return OK;
}
```

#### 双向链表的删除
```c
Status ListDelete(DuLinkList list, int i, ElemType e) {
    if(i < 1 || i > list->data)
        return ERROR;

    int pos = 1;
    DuLNode *pNode = list->next;
    while (pNode && pos < i) {
        pNode = pNode->next;
        ++pos;
    }

    pNode->prior->next = pNode->next;
    pNode->next->prior = pNode->prior;
    free(pNode);
    --list->data;
    return OK;
}
```