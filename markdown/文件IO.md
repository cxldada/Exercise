# 文件IO

这篇记录中讨论的所有函数都是不带缓冲的I/O。不带缓冲指的是每个IO操作都是一个系统调用。
缓冲长度会对这些操作的效率有一定的影响，所以在使用这些函数的时候要考虑好一个合适的缓冲区长度。

这里还记录了原子操作的概念，这对多进程间共享资源很有帮助。

## 文件描述符

对于UNIX而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开一个文件时，内核会向进程返回一个文件描述符。

### 1 文件描述符在UNIX系统中的相关定义

按照惯例，UNIX系统shell会有如下设定：

* 文件描述符0会与标准输入相关联
* 文件描述符1会与标准输出相关联
* 文件描述如2会与标准错误相关联

而且一般的，对于幻数0，1，2都会有一下定义：

* 0 = STDIN_FILENO
* 1 = STDOUT_FILENO
* 2 = STDERR_FILENO

通过这样的定义可以提高代码的可读性。

### 2 文件描述符特点

文件描述符是有一定变化,它的变化范围在0~OPEN_MAX-1之间。OPEN_MAX的值要看相关系统的配置。现在一般都支持64个以上，当然这是对单个进程而言。

### 3 open和openat函数

#### 3.1 函数解释

open 和 openat函数。这两个函数主要是用于打开或者创建一个文件用的。他几乎取代了creat函数，后面写creat函数的时候在说。

函数原型：

```c++
#include <fcntl.h>
int open(const char *path,int oflag,...);
int openat(int fd,const char *path,int oflag,...);
```

参数说明：

path参数很明显就是文件的路径，这里可以是绝对路径也可以是相对路径。以后这一点不具体说明。
oflag参数是定义的一些参数，通过这些参数可以改变打开文件的读写方式等等
后面的可变参数列表，只有在使用open函数创建文件时，用来指定文件权限的。

#### 3.2  oflag参数详解

oflag参数可填的很多，但是分为了两类，一类是必填项，一类是可选项。这两者用逻辑或运算符连接起来

必填项有：

|值|说明|
|:--:|:--:|
|O_RDONLY|只读的方式打开|
|O_WRONLY|只写的方式打开|
|O_RDWR|读写方式打开|
|O_EXEC|只执行打开|
|O_SEARCH|只搜索打开|

**注意：** 

> 1. 上面必填项中的五个值只能选一个
> 2. 最后一个值(只搜索)有很多系统都还没有支持。它的作用就是在目录打开时验证它的搜索权限，后续对此文件描述符操作室，不会再检查搜索权限了，注意是对目录文件

可选项有：

|值|说明|
|:--:|:--:|
|O_APPEND|每次进行写操作时，都将内容追加到文件尾|
|O_CLOEXEC|把FD_COLEXEC常量设置为文件描述符标志|
|O_CREAT|若文件不存在则创建它。使用这个参数时，必须指定最后一个可变参数列表。理由见参数说明|
|O_DIRECTORY|如果path引用的不是目录，则出错|
|O_EXCL|如果同时指定了O_CREAT参数，而文件存在则报错。这常用来测试一个文件是否存在，不存在就创建。这使得检测和创建为一个原子操作|
|O_NOCTTY|如果path引用的是一个终端设备,则不将该设备分配作为此进程的控制终端|
|O_NOFOLLOW|如果path引用的是一个符号链接，则报错|
|O_NONBLOCK|如果path引用的是一个FIFO、块特殊文件或者字符特殊文件，则将文件的后续IO操作设置为非阻塞方式|
|O_SYNC|让每次write等待物理IO操作完成，包括由该write操作引起的文件属性更新所需的IO|
|O_TRUNC|如果文件存在，而且为只写或读写方式打开，则将文件长度截断为0|
|O_TTY_INIT|...|
|O_DSYNC|...|
|O_RSYNC|...|

**注意：由open和openat函数返回的一定是最小的未使用的描述符数值**

#### 3.3 两个函数的区别

可以看到fd参数把两个函数区分开，共有三种可能性：

1. path参数是绝对路径时，fd参数会被忽略，openat函数相当于open函数
2. path参数是相对路径时，fd参数指定了相对路径名在文件系统中的开始地址
3. path参数是相对路径时，fd具有特殊值AT_FDCWD。这种情况，路径名在当前工作目录中获取。

#### 3.4 openat的作用

openat函数是新增的函数。它的作用主要是希望能解决两个问题：

1. 让线程可以使用相对路径名打开文件，而不再是只能相对于当前工作目录。
2. 希望能够解决TOCTTOU(time-of-check-to-time-of-use)问题

> TOCTTOU问题描述：如果有两个基于文件的函数调用，第二个函数调用依赖于第一个函数调用的结果，那么程序就是脆弱的。
> 因为这两个操作不是原子操作，在这两个函数调用之间文件可能发生了变化，这样就导致第一个函数调用的结果不在有效。
> 
> 通常用此错误来骗取特殊文件的权限等等。

### 4 creat函数

creat函数，用来创建一个新文件

```c++
#include <fcntl.h>
creat(const char *path,mode_t mode);
```

其实这个函数等效于

```c++
int open(path,O_WRONLY | O_CREAT | O_TRUNC,mode);
```

现在基本都是使用open函数来创建文件，因为creat函数有个小麻烦，就是它创建的文件都是以只写的方式打开的，如果我们想要以只读或或读写的方式打开，那么就要先creat再close然后在open，相当的麻烦，所以不如直接使用open函数

注意：如果要创建的文件已经存在，creat函数会将文件内容截断为0，且文件的访问权限不变

### 5 close函数

close函数，用来关闭一个打开的文件

```c++
#include <unistd.h> // 注意头文件不一样
int close(int fd);
```

关闭一个文件时还会释放该进程加载文件上的所有记录锁。

当一个进程终止时，内核会自动关闭它所打开的所有文件。

### 6

fcntl函数，这是一个功能很丰富的函数

    #include <fcntl.h>
    
    int fcntl(int fd,int cmd,...);

#### 参数说明

* 第一个参数就不用多解释了，要进行操作的文件描述符
* 第二个参数决定了函数的功能，需要详细说一下

> fcntl函数一共有5中功能，对应有11中cmd参数
>
> * 复制一个已有的文件描述符(cmd = F_DUPFD || F_DUPFD_CLOEXEC) 
> * 获取/设置文件描述符状态(cmd = F_GETFD || F_SETFD)
> * 获取/设置文件状态标识(cmd = F_GETFL || F_SETFL)
> * 获取/设置一步I/O所有权(cmd = F_GETOWN || F_SETOWN)
> * 获取/设置纪录锁(cmd = F_GETLK || F_SETLK || F_SETLKW)
>
> 文件状态值的是文件的打开方式，前面的函数中有说过，文件的打开方式有五个单选项，
> 这五个打开方式是互斥的，所以通过F_GETFL获取到文件状态标示后需要用O_ACCMODE来获取相应的文件状态
>

* 第三个参数跟第二个参数有关

fcntl函数的返回值跟命令值有关，如果出错，所有命令都返回-1

#### 注意项

* 修改文件描述符标志或者文件状态标志时必须要谨慎，不能只是执行F_SETFD或者F_SETFL命令，这个会关闭之前开启的某些标志，所以最好先获取原有标志然后进行与运算符进行设置
* 设置某个标志位，就与相应的标识符进行与操作，关闭某个标志位，则是与上去反的标志位