# 进程环境

## 简介

后面要学习进程控制原语，所以在此之前要先了解一下UNIX系统中的进程环境，才能更好的学习后面的进程控制原语。这一篇博文要记录的东西有以下几点：

1. 当程序执行时，main函数是如何调用的
2. 命令行参数是如何传递给新程序的
3. 典型的存储空间布局是什么样的
4. 如何分配另外的存储空间
5. 进程如何使用环境变量
6. 进程的各种不同终止方式
7. longjmp和setjmp函数以及它们与栈的交互作用
8. 查看进程资源限制

## main函数

> 当内核执行C程序时，在调用main函数之前会先调用一个特殊的启动例程。
>
> 可执行程序文件将此启动例程指定为程序的其实地址----由连接编辑器设置的，连接编辑器是由C编译器调用的。
>
> 启动例程从内核获取命令行参数和环境变量值，然后为按上述方式调用main函数做好准备

## 进程终止

有8中方式让进程终止，其中有五中正常终止和三种异常终止

* 正常终止：
  * 从main返回
  * 调用exit
  * 调用\_exit或\_Exit;
  * 最后一个线程从启动例程返回
  * 从最后一个线程调用`pthread_exit`
* 异常终止：
  * 调用abort()
  * 接到一个信号
  * 最后一个线程对取消请求做出响应

### 退出函数

有3个函数用于正常终止一个程序，如下

```c
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);
```

* _exit和\_Exit使程序结束，并立即进入内核。exit会先执行一些清理工作，然后返回内核
* exit函数总会执行一些标准IO库的清理工作，对所有打开的流调用`fclose`。
* 三个函数都有一个整型参数，他们表示为程序终止状态。
* 在main函数中返回一个整型和调用exit(int)的作用是相同的

有三种情况，进程的终止状态是未定义的

1. 调用上述三个函数时不带终止状态
2. `main`执行了一个无返回值的`return`语句
3. `main`没有声明返回类型为整型

### `atexit`函数

> 按照ISO C的规定，一个进程可以登记多至**32**个函数，这些函数由exit函数自动调用。我们称这些函数为终止处理程序，并调用`atexit`函数登记它们

```c
#include <stdlib.h>
int atexit(void (*func)(void));
// 成功返回0，出错返回非0
```

* `atexit`函数的参数是一个没有返回值，空参数列表的函数指针。
* 函数登记的顺序与最终exit函数的调用顺序是相反的(先进后出)
* 一个函数可以登记多次，当然也会执行多次

**如若程序调用`exec`函数族中的任意函数，将清除所有已安装的终止程序**

**注意：**内核使进程执行的唯一方式就是只用一个exit函数。进程自愿终止的唯一方式就是调用_exit函数或者\_Exit函数。进程也可以非自愿的由一个信号终止

## 命令行参数

当执行一个程序时，调用exec的进程可将命令行参数传递给新的程序。这就是UNIX shell的一部分常规操作

ISO C和`POSIX.1`都要求`argv[argc]`是一个空指针，所以我们可以如下来处理参数循环

`for (i = 0; argv[i] != NULL; i++)`

## 环境表

每个程序都会收到一张环境表。与参数表一样，环境表也是一个字符指针数组。

全局变量environ包含了该指针数组的地址：`extern char **environ;`

## C程序的存储空间布局

C程序由下列几部分组成：

* 正文段。存放由CPU执行的机器指令部分。通常这部分是只读的，以防止程序由意外而修改其指令
* 初始化数据段。在**任何函数之外**，需要**明确赋初值**的变量，都存放在初始化数据段中。
* 未初始化数据段。在**任何函数之外声明的**函数，内核会将此段中的数据初始化为0或空指针。
* 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
* 堆。通常在堆中进行动态存储分配。由于历史惯例，堆位于未初始化数据段和栈之间。

上面列出的几部分是典型的存储空间布局，但不一定是所有系统都是这么实现的。下面典型的存储空间安排图

| 高地址 | 环境变量和命令行参数 |                                               |
| :----: | :------------------: | :-------------------------------------------: |
|        |          栈          |                 向低地址生长                  |
|        |          堆          |                 向高地址生长                  |
|        |    未初始化数据段    | 不存储磁盘文件中，由exec函数初始化为0或空指针 |
|        |     初始化数据段     |        存储磁盘文件中，由exec函数读取         |
| 低地址 |        正文段        |        存储磁盘文件中，由exec函数读取         |

**可以使用`size`命令查看程序的正文段、数据段和`bss`段的长度**

## 共享库

> 共享库使得程序不再需要包含公用的库函数，大大减小了可执行文件的长度，但是增加了一些运行时间开销。这种时间开销发生在该程序第一次执行时，或者每个共享库第一被调用时，它们用动态链接的方式将程序和共享库进行链接。
>
> 使用共享库还有一个优点，就是可以用库函数的新版本替换老版本而不用重写代码，当然前提是库函数的名字和参数没有发生变化
>
> 使用size命令查看可执行文件的数据段和正文段的大小

## 存储空间分配

ISO C提供了3个用于动态分配的函数。如下：

```c
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj,size_t size);
void *realloc(void *ptr,size_t newsize);
// 成功返回非空指针，出错返回NULL
void free(void *ptr);
```

* `malloc`函数，分配指定的字节数的存储区。此存储区中的初始值不确定
* `calloc`函数，为指定数量指定长度的对象分配存储空间。分配的存储空间中的初始值都为0
* `realloc`函数，增加或减少指定存储区的长度。增加长度时，如果尾部没有足够的空间，则会重新找一个满足长度的未使用的存储空间，并将数据拷贝至此，然后返回新存储的地址。
* 这三个函数返回的指针一定是适当对齐的，使其可用于任何数据对象
* `free`函数释放`ptr`所指向的存储空间。被释放的空间通常被送入可用存储区池，以后，可在调用上面三个分配函数的时候再分配
* 这3个分配例程都是使用`sbrk`系统调用实现的。
* 大多数实现所分配的存储空间都比所要求的的稍大一些，额外的空间用来记录管理信息——分配块的长度、指定下一分配块的指针等等信息
* 有一些比较致命的错误：
  * 释放一个已经释放了的块
  * 调用`free`时所用的指针不是3个`alloc`函数的返回
  * 忘记`free`分配的块，会导致内存泄漏

**可以了解一下：`alloca`函数，它在栈上分配空间，所以不用担心内存泄漏的问题**

## 环境变量

环境字符串的形式如下：

`name=value`

UNIX系统并不查看这些字符串，它们的解释完全取决于各个引用程序。

### 获取环境变量的函数

ISO C定义了一个函数，用来去环境变量值。函数声明如下：

```c
#include <stdlib.h>
char *getenv(const char *name);
```

* 此函数返回一个指针，它执行`name=value`中的`value`。
* 我因该使用这个函数来获取环境变量值，而不是使用环境表指针`environ`

### 其他操作环境变量的函数

除了获取环境变量的值，我们还可以设置环境变量的值，当然后面的学习中会讲到，设置当前进程的环境变量值，并不会影响父进程的环境，但是会印象它本身和它其后产生的进程。函数声明如下：

```c
#include <stdlib.h>
int putenv(char *str);
// 成功返回0，出错返回非0

int setenv(const char *name,const char *value,int rewrite);
int unsetenv(const char *name);
// 成功返回0，出错返回-1
```

* `putenv`函数将形如`name=value`的字符串，放到环境变量中，如果`name`已经存在，则先删除原来的值
* `setenv`函数，将`name`和`value`作为函数参数进行传递。如果`name`已经存在，则
  * 若rewrite非0，则先删除
  * 若rewrite为0，则不删除，也不设置，并且不会出错返回
* `unsetenv`删除`name`的定义，即使不存在也不会出错。

注意：`setenv`必须要分配存储空间，而`putenv`不需要。所以有很多软件都是用`putenv`，但是还是建议分配存储空间，不然临时变量的空间被重用是会导致设置的变量错误

### 分析修改环境变量的函数

> 修改环境变量的值是比较复杂的，查看上面存储空间分配一节中的表格图，可以知道，环境变量和命令行参数是在空间分布图的上方，也就是高地址。
>
> 那么删除一个字符串很简单，只需要将字符串后面的指针，陆续向前移动一个就可以了。
>
> 但是增加一个就很麻烦了。因为环境表通常占用进程地址空间的顶部，所有它不能再向高地址方向扩展。同时也不能移动它之下的各栈帧，所以它也不能向低地址扩展。
>
> 下面就分析一下增加环境变量时，这些函数是如何实现的

1. 如果修改一个现有的`name`
   1. 如果新`value`的长度小于或等于现有`value`长度，则只要将新字符串复制到原字符串所用的空间中
   2. 如果行`value`的长度大于原长度，则必须调用`malloc`为新字符串分配空间，然后将新字符串复制到该空间中，接着使环境表中针对`name`的指针指向新分配区。
2. 如果新增加一个`name`就复杂了
   1. 如果这是第一次增加新`name`,则必须调用`malloc`为新的**指针表**分配空间。接着，将原来的环境表复制到新分配区，并将指向新`name=value`字符串的指针存放在该指针表的尾部，然后又将一个空指针存放在其后，作为结束符。最后使environ指向新指针表。这样的话，想象一下空间分配图，环境表指针指向了堆中的一块存储区，然后改存储区的每项又指向顶部的环境变量值
   2. 如果不是第一次增加`name`。则可知以前调用`malloc`在堆中为环境表分配了空间，所有只需要调用`realloc`函数，修改存储区的大小，在将新加的指针存入尾部，然后在后面跟一个空指针就可以了

## 非局部跳转函数

C语言中，goto可以实现在函数内部跳转功能，但是它能够跨函数执行，所以就有了下面两个函数，用来进行跨函数跳转

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
// 直接调用返回0，若从longjmp函数返回，则返回非0
void longjmp(jmp_buf env,int val);
```

* `jmp_buf`参数是用来存储调用`longjmp`时，能用来恢复栈状态的所有信息
* `setjmp`和`longjmp`中的的`jmp_buf`参数应该是同一个，所以最好定义为全局变量
* `longjmp`的`val`参数是`setjmp`的返回值。这样的话就可以在有多个`longjmp`函数的时候，区分到底调用的是哪一个`longjmp`函数

调用这两个函数的时候有一个问题：自动变量、寄存器变量和易失变量，他们是恢复到`setjmp`时的值，还是保持`longjmp`时的值。这个答案是不确定的，需要查看你所使用的UNIX系统的手册

## 获取进程资源值的函数

每个进程都有一组资源限制，其中一些可以用下面两个函数查询和更改

```c
#include <sys/resource.h>
int getrlimit(int resource,struct rlimit *rlptr);
int setrlimit(int resource,const struct rlimit *rlptr);
// 成功返回0，出错返回非0

struct rlimit
{
    rlim_t rlim_cur;	// 软限制：当前限制
    rlim_t rlim_max;	// 硬限制：软限制可以设置的最大值
};
```

更改资源限制时，必须遵循下列3条规则：

1. 任何一个进程都可以讲一个软限制更改为小于或等于其硬限制值
2. 任何一个进程都可以降低其硬限制，但它必须大于或等于其软限制。**这种限制普通用户而言是不可逆的**
3. 只有root用户可以提高硬限制值

resource参数可以取的值是下列之一：

|  resource的取值   |                            说明                            |  未实现的系统   |
| :---------------: | :--------------------------------------------------------: | :-------------: |
|    `RLIMIT_AS`    |                进程的可用存储空间的最大长度                |  `macOS10.6.8`  |
|   `RLIMIT_CORE`   |         core文件的最大字节数，0则阻止创建core文件          |        -        |
|   `RLIMIT_CPU`    |     CPU时间的最大值(秒)，当超过时，会发送`SIGXCPU`信号     |        -        |
|   `RLIMIT_DATA`   | 数据段的最大字节长度(初始数据段、非初始化数据段和堆的总和) |        -        |
|  `RLIMIT_FSIZE`   |   可以创建的文件的最大字节长度。超过会发出`SIGXFSZ`信号    |        -        |
| `RLIMIT_MEMLOCK`  |  一个进程使用`mlock`函数能够锁定在存储空间的最大字节长度   |   `Solaris10`   |
| `RLIMIT_MSGQUEUE` |        进程为`POSIX`消息队列可分配的最大存储字节数         | `仅linux实现了` |
|   `RLIMIT_NICE`   |      为了影响进程的调度优先级，nice值可设置的最大限制      | `仅linux实现了` |
|  `RLIMIT_NOFILE`  |                 每个进程能打开的最多文件数                 |        -        |
|  `RLIMIT_STACK`   |                      栈的最大字节长度                      |        -        |

* 这些限制值的修改会影响该进程本身和其产生的子进程。